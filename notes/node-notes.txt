INSTALLATIONS

npm init -y
this command basically says: we are using this folder for an npm based project, (npm init), the (-y) says fill the package.json with the base information.

Node        - nodejs.org manual download.                               [JS Server technology]
NPM         - comes with node.                                          [node package manager]
Nodemon     - npm install -g nodemon                                    [keeps your node server up and running when you fix crashes]
Bower       - npm install -g bower                                      [front-end package manager]
Express     - npm install express (don't -g install. just doesn’t work) [light, flexible node framework. makes routing a breeze]
EJS         - npm install ejs (stands for Embedded JavaScript)          [templating engine. puts <script> tags to shame.]
body-parser - npm install body-parser                                   [helps us handle post data. express can't]
socket.io   - npm install socket.io                                     [facilitates realtime connection without http slowing us down]

passing "--save" after the name of the package will save it to your package.json so you can move this dependency configuration around to different projects easy peezy with:
"npm install"



DESCRIPTION

How
As previously mentioned, Node.js uses Chrome's V8 engine to efficiently interpret JavaScript. V8, however, is written in C++ and JS. Why is this important? Well, it allows a relatively high-level language like JavaScript to be compiled to code that is run directly by the CPU! By using this engine, we can skip a bunch of steps in the runtime processes. That means speed, but it also means that our JavaScript interpreting scales to the power of our computer!

Sockets
One cool thing about Node.js is its ability to use WebSockets, a technology that allows a continuous, non-blocking connection between the client and server.

If the traditional client-server model is something like morse code, where only one party can send data at a time, non-blocking connections allow both parties to send information at the same time. A phone call is a prime example of non-blocking communication: You can talk to your friend while your friend is speaking to you concurrently. With Node.js, we can easily set up these socket connections and have a persistent connection from each client to a server, which means we can actually force information onto the browser without the need of an HTTP request!

Use cases
Sockets make Node.js a great tool for making real-time applications. These are applications that exchange information as the users input it, with no lag. Things like chat rooms and multiplayer games are great examples of Node’s strengths. Also, Node servers are able to support lots of connections. A single node server can hold 200,000 connections whereas a single Apache server tops out at around 20,000 connections. 

Drawbacks
Heavy computation is a killer in a Node server, primarily due to poor memory management. In addition, if logic is required before entering the event loop, Node’s performance will decline dramatically. Similarly, Node is often used with noSQL databases such as MongoDB, which we’ll be using in this course. Mongo also uses a V8 engine core, but it doesn’t have the same event-loop (it’s just a worker), so large numbers of inefficient queries can back up that worker. This could take up enough memory that it prevents the event-loop from resolving events, making Node much less awesome.

Node also has a very 'batteries-not-included' unopinionated style, favoring configuration over convention. Out of the box, we won't be able to do all the amazing things a full featured framework like Ruby on Rails can do. We'll need to bring in middleware and do our own configuration to really get the most out of Node!

The upshot? You should use Node for what it’s good for: making servers capable of handling lots of connections and moving data quickly!




FULL CODINGDOJO DEPENDENCY/MODULE LIST

Nodemon
Using nodemon instead of the node command in your terminal will automatically re-run your JavaScript file or project whenever you save something. That means no more manual server restarts!

Bower
To manage our front-end dependencies, we'll be using another package manager called bower. This will save us from having to hunt down the perfect CDN for important libraries like jQuery and Bootstrap.

EJS
Embedded Javascript is the templating engine we will use to render our views. When using EJS, your node server will take the .ejs file you wrote, parse through it, resolve all of the Javascript in the file, and then send a 'rendered' HTML page to the client. This is extra computation that the server will be required to do, and later we'll replace EJS with a full front end framework like Angular.

Express
Technically a Node module, but let's talk about it here too since it gets it's own letter in the acronym! Express is a wonderful set of tools that help us write rules for incoming HTTP requests. Express is arguably the most useful Node module in your collection, and only rarely will we not use it.

body-parser
Guess what body-parser is used for? Parsing the body! We'll use this piece of middleware to parse information out of HTTP requests made to our server. Body-parser is incredibly flexible, and will be used to not only pull POST data out of requests, but can also snag data encoded into URLs via GET requests, and later you'll use body-parser to pull raw JSON.

socket.io
This node module will enable you to use web sockets within your application, we'll get into it more later. You will use socket.io for just this chapter!




FS MODULE / HTTP MODULE

An essential part of any server is the ability to read and write files.  Reading a file is how we obtain the content to serve to clients, and writing it is how we output content to the client.  If we don't have a way of doing this, we're not going to be able to build a server!   That is why the creators of Node.js built the fs (file system) module.  The FS module allows us to do exactly what we need: read and write content from files, and it is by default included in Node.js. It is very rare that you will see the HTTP module used without the fs module.  The HTTP module is the module that allows us to build a web server that accepts HTTP requests and can serve responses. Combining the fs and http modules, we can create simple web servers quite easily.




MODULARIZING NOTES

Using require();
You'll notice that we require() the string "./my_module". Two things to note:

There is no .js at the end of the file. The require method automatically looks for JavaScript files, so we don't need to include a file extension.

The files app.js and my_module.js are in the same directory. Normally, the require() method looks for node modules that aren't in the same directory as the file that is running; by default, the require() method looks for the modules located in a folder called node_modules. To tell require() to look in the current directory (i.e. the folder that the file is located in) we have to include "./" in front of the file path. "./" (dot-slash) is the file path for the current directory.




STATIC CONTENT / TEMPLATES

Generally, there are two ways to serve HTML/CSS/JS -- through Static Content or Templates. 
Static Content -- Serving a static HTML/CSS/JS file from the backend in response to a request.
Templates -- Using a view/templating engine to generate HTML (PHP, embedded ruby, embedded JavaScript)


Serving Static with Express
app.use(express.static(__dirname + "/static"));
// we would have a dir called static we place all the static HTML/CSS/JS files in.
// in their example, the route i used to access it from localhost was '/main.html'


Serving Templates with Express 
~~~ CHECK OUT first-express PROJECT ~~~

we use EJS - npm install ejs

// This sets the location where express will look for the ejs views
    app.set('views', __dirname + '/views'); 
// Now lets set the view engine itself so that express knows that we are using ejs as opposed to another templating engine like jade
    app.set('view engine', 'ejs');

from here we hardcoded data to render when a certain url was req'd. in our '.ejs' file in the views, then, we use <% %> and <%= %> to embed JS in the html code.




HTTP METHODS

GET - for passing insensitive info
POST - for passing sensitive info




SOCKETS

Servers also have one kind of listener, however they have three kinds of emitters. They can 
1) emit to all connected socket users, 
2) respond back directly to a client that initiated a socket message to us, and 
3) broadcast to all clients except for the one client that initiated a socket message to us. 


Testing socket activities is an art form. The key points for testing socket stuff:

* Use multiple browsers (Firefox and Chrome are the best tandem. Safari just isn't as good for debugging).
* If you need multiple connections in the same browser, use an incognito/private browsing window. Not just another tab!!
* When your server restarts, refresh every window. 
* You do not need to wait to deploy to start testing your projects with multiple clients! Just go to your terminal and run the command ifconfig to find your ip address. Give this to a cohort mate and they can type that into their nav bar followed by a colon : and the port you are using to run your project, and you will be able to test your sockets with them. It will be something like 192.163.0.2:1337.